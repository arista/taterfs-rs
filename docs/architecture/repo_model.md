# RepoModel

A RepoModel is an object model around a [Repo](./repository_interface.md) that presents a higher-level API for interacting with that Repo.

In most cases, the model object is a thin wrapper around a corresponding [backend storage object](./backend_storage_model.md).  The model object might be constructed with only an ObjectId (or branch name for a BranchModel), and a place to hold that backend storage object, fetched lazily when needed.

## RepoModel interface

```
RepoModel {
  new(repo) -> RepoModel
  async default_branch() -> BranchModel

  // performs a binary search for the given branch
  async get_branch(name: string) -> Option<BranchModel>

  // updates the repo with a new root generated by calling f().  There are no transactional semantics around this, so it does the next best thing by checking to see if the root has changed while f() was running.  If so, it tries again, calling f() again, up to max_attempts times
  async update(f: async () -> WithComplete<new root ObjectId>, max_attempts) {
    loop up to max_attempts times, then fail out {
      starting_root_id = get the repo's current root id
      new root id, complete = run f()
      await the complete
      if the repo's current root is still the same as starting_root_id, write the new_root_id and return.  Otherwise let it loop again, except that it uses the value it just got as the new starting_root_id
    }
  }

  // Convenience method for constructing a new Root with timestamp and previousRoot filled in, and with branches and defaultBranchName filled in, inherting from the existing Root if not specified
  async create_next_root(branches_id: Option<ObjectId>, default_branch_name: Option<string>) -> WithComplete<new Root ObjectId>

  // Returns a new Branches object that inherits from the current Branches, but with the given branch_name set to the given commit (or removed it the commit is None)
  async create_next_branches(branch_name: string, commit_id: Option<ObjectId>) -> WithComplete<new Branches ObjectId>
}
```
Lazily fetches and caches the current "Root" object, using it as the source of its info.

The functions that return a BranchModel will find the Branch in the branches list and construct with BranchModel with that Branch.

The create_next_branches function should use the Branches [list_builder](./list_builder.md)

## BranchModel interface

```
BranchModel {
  branch_name: string
  branch: Branch
  async commit() -> CommitModel
}
```
## CommitModel interface

```
CommitModel {
  id: ObjectId
  async root() -> DirectoryRootModel
  
  async create_next_commit(directory_id: ObjectId, commit_metadata: Option<CommitMetdata>, additional_parents: Option<Vec<commit ObjectId's>>) -> WithComplete<commit ObjectId> {
    create a new Commit, with this commit as the first parent, plus any additional parents
    if CommitMetadata is None, or its timestamp is None, then fill in the timestamp with the current time
    write the commit to the repo
  }
}
```
Constructed with the commit's id.  Lazily fetches and caches the backend "Commit" object, using it as the source of its info

## RootModel interface

```
DirectoryRootModel {
  // Returns the root directory
  directory() -> DirectoryModel

  // Resolves the given path starting from the root, using "/" as a path separator.
  async resolve_path(path) -> ResolvePathResult

  // Resolves the given path, with an error if the result is not a DirectoryEntry or Root.  For the non-error cases, the resulting Directory is returned
  async resolve_path_to_directory(path) -> DirectoryModel
}
```
Constructed with the id of the commit's directory.  Lazily fetches and caches the backend "Commit" object, using it as the source of its info

## DirectoryModel interface

```
DirectoryModel {
  id: ObjectId
  async entries() -> EntryModelList
  async find_entry(name: string) -> Option<EntryModel>
}

EntryModelList {
  async next() -> Option<EntryModel>
}

enum EntryModel {
  File(FileEntryModel)
  Directory(DirectoryEntryModel)
}

impl EntryModel {
  name() -> string
}

FileEntryModel {
  name: string
  size: number
  executable: bool
  file: FileModel
}

DirectoryEntryModel {
  name: string
  directory: DirectoryModel
}

enum ResolvePathResult {
  None
  Root
  Directory(DirectoryEntryModel)
  File(FileEntryModel)
}
```

DirectoryModel is constructed with the directory's id.  Lazily fetches and caches the backend "Directory" object as needed, using it as the source of its info.

The find_entry method should use the appropriate [list_search](./list_search.md) function.

## FileModel interface

```
FileModel {
  id: ObjectId
}
```

FileModel is constructed with the directory's id.  Lazily fetches and caches the backend "Directory" object as needed, using it as the source of its info.

